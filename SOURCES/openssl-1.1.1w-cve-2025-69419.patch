From e5954ef3d692a5d3ed25ad7b3cc9600630133eba Mon Sep 17 00:00:00 2001
From: Dmitriy Popov <dpopov@cloudlinux.com>
Date: Thu, 29 Jan 2026 04:17:25 +0200
Subject: [PATCH 6/7] openssl-1.1.1w-cve-2025-69419

Backport the following upstream commits:

    ---- 1 ----
    From 53b78f2a49cd1ede1c4f86d53b2f6d9ff9e1620e Mon Sep 17 00:00:00 2001
    From: Norbert Pocs <norbertp@openssl.org>
    Date: Thu Dec 11 12:49:00 2025 +0100
    Subject: [PATCH] Check return code of UTF8_putc

    In OPENSSL_uni2utf8() and do_buf(), the code did not check the return
    value of UTF8_putc/bmp_to_utf8(). If these functions fail and return
    a negative value, it would cause an out-of-bounds write.

    CVE-2025-69419

    Signed-off-by: Norbert Pocs <norbertp@openssl.org>

    Reviewed-by: Nikola Pajkovsky <nikolap@openssl.org>
    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/29376)

    ---- 2 ----
    From 7e535fe6b16f3551252b336f911cee190ff4a4a6 Mon Sep 17 00:00:00 2001
    From: Nikola Pajkovsky <nikolap@openssl.org>
    Date: Fri Jan 9 16:30:10 2026 +0100
    Subject: [PATCH] apps: check OPENSSL_uni2utf8 return value

    After the fix for CVE-2025-69419, OPENSSL_uni2utf8() can now return
    NULL on error. The pkcs12 app must check for this NULL return value
    to avoid dereferencing a NULL pointer.

    Reviewed-by: Viktor Dukhovni <viktor@openssl.org>
    Reviewed-by: Paul Dale <paul.dale@oracle.com>
    Reviewed-by: Tomas Mraz <tomas@openssl.org>
    (Merged from https://github.com/openssl/openssl/pull/29590)

Signed-off-by: Dmitriy Popov <dpopov@cloudlinux.com>
---
 apps/pkcs12.c           | 6 ++++++
 crypto/asn1/a_strex.c   | 6 ++++--
 crypto/pkcs12/p12_utl.c | 5 +++++
 3 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/apps/pkcs12.c b/apps/pkcs12.c
index 8c5d963..8910f74 100644
--- a/apps/pkcs12.c
+++ b/apps/pkcs12.c
@@ -561,6 +561,12 @@ int pkcs12_main(int argc, char **argv)
             if (utmp == NULL)
                 goto end;
             badpass = OPENSSL_uni2utf8(utmp, utmplen);
+            if (badpass == NULL) {
+                BIO_printf(bio_err, "Verbatim password did not match, and fallback conversion to UTF-8 failed\n"
+                                    "The password entered or the input encoding may be wrong\n");
+                OPENSSL_free(utmp);
+                goto end;
+            }
             OPENSSL_free(utmp);
             if (!PKCS12_verify_mac(p12, badpass, -1)) {
                 BIO_printf(bio_err, "Mac verify error: invalid password?\n");
diff --git a/crypto/asn1/a_strex.c b/crypto/asn1/a_strex.c
index 284dde2..843b0f9 100644
--- a/crypto/asn1/a_strex.c
+++ b/crypto/asn1/a_strex.c
@@ -203,8 +203,10 @@ static int do_buf(unsigned char *buf, int buflen,
             orflags = CHARTYPE_LAST_ESC_2253;
         if (type & BUF_TYPE_CONVUTF8) {
             unsigned char utfbuf[6];
-            int utflen;
-            utflen = UTF8_putc(utfbuf, sizeof(utfbuf), c);
+            int utflen = UTF8_putc(utfbuf, sizeof(utfbuf), c);
+
+            if (utflen < 0)
+                return -1; /* error happened with UTF8 */
             for (i = 0; i < utflen; i++) {
                 /*
                  * We don't need to worry about setting orflags correctly
diff --git a/crypto/pkcs12/p12_utl.c b/crypto/pkcs12/p12_utl.c
index 43b9e3a..4998fcc 100644
--- a/crypto/pkcs12/p12_utl.c
+++ b/crypto/pkcs12/p12_utl.c
@@ -207,6 +207,11 @@ char *OPENSSL_uni2utf8(const unsigned char *uni, int unilen)
     /* re-run the loop emitting UTF-8 string */
     for (asclen = 0, i = 0; i < unilen; ) {
         j = bmp_to_utf8(asctmp+asclen, uni+i, unilen-i);
+        /* when UTF8_putc fails */
+        if (j < 0) {
+            OPENSSL_free(asctmp);
+            return NULL;
+        }
         if (j == 4) i += 4;
         else        i += 2;
         asclen += j;
-- 
2.34.1

